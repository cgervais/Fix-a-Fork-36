/*	Copyright Eric Helgeson 2023-2024.*/// some unused attempts to get folders working#include <unix.h>/*// some stuff in main just to get a stdout window	printf("hello\n");	//fflush(stdout);	while(!Button());	ExitToShell();// This does seem to work!static Boolean isFSSpecFolder(FSSpec *fss){	HFileInfo pb;	OSErr err = 0;		pb.ioCompletion = 0L;	pb.ioNamePtr = &fss->name[0];	pb.ioVRefNum = fss->vRefNum;	pb.ioFDirIndex = 0;	pb.ioDirID = fss->parID;		err = PBGetCatInfoSync((CInfoPBPtr)&pb);	if((pb.ioFlAttrib & 0x10) != 0)	{		puts("folder");		return true;	} else {		puts("not folder");		return false;	}}// This does seem to work but i only haven parentID so never get the actual dir i want.Str255 filename, temp;void loopFilesInDir(long dirID, short vRefNum, char *dirName){	CInfoPBRec cipbr;	HFileInfo *fpb = (HFileInfo *)&cipbr;	DirInfo   *dpb = (DirInfo *)&cipbr;	short rc, idx;	Str255 dirFullName;	char cstrName[32] = {0};	// dont need probably	//strcpy((char *) dirFullName, dirName);	printf(" Searching: %s\n", dirName);		fpb->ioVRefNum = vRefNum; // example had 0... cant assume defaulvol...?	fpb->ioNamePtr = filename;		for(idx=1; true; idx++) {		fpb->ioDirID = dirID;		fpb->ioFDirIndex = idx;				rc = PBGetCatInfo(&cipbr, false);		if(rc) break;				pToCStr(filename,cstrName );		printf("%s\n", cstrName);	}	}/* an attempt to get a dirID from a FSSpecshort GetDirID(FSSpec *fss, long *dirID){	CInfoPBRec rec;	short err = 0;	Boolean isFolder, wasAlias;	int loopCnt = 0;tryAgain:	rec.hFileInfo.ioVRefNum = fss->vRefNum;	rec.hFileInfo.ioDirID = fss->parID;	rec.hFileInfo.ioNamePtr = fss->name;	rec.hFileInfo.ioFDirIndex = -1; // dir		PBGetCatInfoSync(&rec); //err handle	return err;	if( !(rec.hFileInfo.ioFlAttrib & 0x10) ) {		fss->parID = rec.hFileInfo.ioFlParID;		fss->vRefNum = rec.hFileInfo.ioVRefNum;		loopCnt++;		if(loopCnt > 2)			return dirNFErr;		goto tryAgain;	}	*dirID = rec.dirInfo.ioDrDirID;	return err;} */pascal OSErr DoOpenDoc(AppleEvent *event, AppleEvent *reply, long handlerRefcon){	CInfoPBRec cipbr;	HFileInfo *fpb = (HFileInfo *)&cipbr;	DirInfo   *dpb = (DirInfo *)&cipbr;	FSSpec fss;	AEDescList docList;	OSErr err = noErr;	long index, itemsInList;	Size actualSize;	AEKeyword keywd;	DescType returnedType;	short fRefNum = 0;	char cstrName[32] = {0};	long dirID = 0;		err = AEGetParamDesc(event, keyDirectObject, typeAEList, &docList);	if(err != noErr) return err;	err = AECountItems(&docList, &itemsInList);	if(err != noErr) return err;		for(index = 1; index <= itemsInList; index++)	{		err = AEGetNthPtr(&docList, index, typeFSS, &keywd, &returnedType, (Ptr)&fss, sizeof(fss), &actualSize);		if(err) return err;		printf("fss.vRefNum: %d\n", fss.vRefNum);		printf("fss.parID: %d\n", fss.parID);		pToCStr(fss.name, cstrName);		printf("fss.name: %s\n", cstrName);		if(isFSSpecFolder(&fss)) {			// GetDirID(&fss, &dirID);			//ListFiles(fss.vRefNum, fss.parID);			loopFilesInDir(fss.parID, fss.vRefNum, cstrName);		}		err = FSpOpenDF(&fss, fsRdPerm, &fRefNum);		if(err) return err;				err = openFile(fss.name, fRefNum, fss.vRefNum, fss.parID);		if(err) 			return err;		else			gHandledByDnD = true;	}	AEDisposeDesc(&docList);	return noErr;}// This does not work on 7.1 and below.// An attempt to send the finder update apple event to refresh the folder.void SendFinderSyncEvent(FSSpec spec){	const OSType sig = 'MACS';	OSErr err = 0;	Str255 errString;	AppleEvent event, reply;	AEAddressDesc addr;	if(!gHasAppleEvents)		return;		AECreateDesc( typeApplSignature, &sig, sizeof sig, &addr);	AECreateAppleEvent('fndr', 'fupd', &addr, kAutoGenerateReturnID, kAnyTransactionID, &event);	AEPutParamPtr(&event, keyDirectObject, typeFSS, &spec, sizeof(spec));	AESend(&event, &reply, kAENoReply, kAENormalPriority, kNoTimeOut, NULL, NULL);	AEDisposeDesc(&event);}*/